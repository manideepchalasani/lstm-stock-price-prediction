# -*- coding: utf-8 -*-
"""Copy of TCS

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Y9D_c91Vd6agPDvJMxQb4pR_qLeEfFQd
"""

import pandas as pd
stock_data = pd.read_csv('./TCS.csv',index_col='Date')
stock_data.head()

def mean_absolute_percentage_error(y_true, y_pred):
    y_true, y_pred = np.array(y_true), np.array(y_pred)
    return np.mean(np.abs((y_true - y_pred) / y_true)) * 100

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from keras.models import Sequential
from keras.layers import Dense, LSTM
from sklearn.metrics import mean_squared_error
from sklearn.preprocessing import MinMaxScaler

# Read the data
stock_data = pd.read_csv('./TCS.csv', index_col='Date')

# Remove any rows with missing values
stock_data.dropna(inplace=True)

# Extract the required columns
selected_columns = ['Close', 'PE Ratio', 'PB Ratio', 'PS Ratio']
stock_data = stock_data[selected_columns]

# Get the closing prices, PE, PB, and PS ratios
X = stock_data.values

# Split the data into train and test
train_split = 0.8
split_idx = int(np.ceil(len(X) * train_split))
train = X[:split_idx]
test = X[split_idx:]

# Scale the data
scaler = MinMaxScaler(feature_range=(0, 1))
train_scaled = scaler.fit_transform(train)
test_scaled = scaler.transform(test)

# Scale the closing prices separately
closing_price_scaler = MinMaxScaler(feature_range=(0, 1))
closing_price_scaler.fit_transform(X[:, 0].reshape(-1, 1))

# Reshape the data to LSTM input shape
def create_dataset(X, lookback=1):
    X_data, y_data = [], []
    for i in range(len(X) - lookback):
        X_data.append(X[i:(i + lookback), :])
        y_data.append(X[i + lookback, 0])
    return np.array(X_data), np.array(y_data)

lookback = 1
X_train, y_train = create_dataset(train_scaled, lookback)
X_test, y_test = create_dataset(test_scaled, lookback)

# Create the LSTM model
model = Sequential()
model.add(LSTM(50, activation='relu', input_shape=(lookback, X.shape[1])))
model.add(Dense(1))
model.compile(optimizer='adam', loss='mse')

# Train the model
model.fit(X_train, y_train, epochs=500, batch_size=32)

# Generate predictions
y_pred = model.predict(X_test)

# Inverse transform the predictions and target to original scale
y_pred_inv = closing_price_scaler.inverse_transform(y_pred)
y_test_inv = closing_price_scaler.inverse_transform(y_test.reshape(-1, 1))

# Print the evaluation metrics
rmse = mean_squared_error(y_test_inv, y_pred_inv, squared=False)
mape = mean_absolute_percentage_error(y_test_inv, y_pred_inv)
print('Test RMSE: %.3f' % rmse)
print('Test MAPE: %.3f' % mape)

# Plot the actual and predicted values
plt.figure(figsize=(10, 5))
plt.plot(y_test_inv, label='Actual')
plt.plot(y_pred_inv, label='Predicted')
plt.legend()
plt.show()
print(y_pred_inv)

# Load the latest day's data
latest_data = stock_data.tail(lookback+1)

# Scale the latest day's data
latest_data_scaled = scaler.transform(latest_data[['Close']])

# Reshape the data to LSTM input shape
X_latest = latest_data_scaled[:-1].reshape(1, lookback, 1)

# Predict the next day's stock price
y_latest_pred = model.predict(X_latest)

# Inverse transform the prediction to original scale
y_latest_pred_inv = scaler.inverse_transform(y_latest_pred.reshape(-1, 1))

# Print the predicted stock price
print('Predicted stock price for the next day:', y_latest_pred_inv[0][0])

# Import necessary libraries
import pandas as pd
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense

# Load the stock data
stock_data = pd.read_csv('TCS.csv')

# Add a column to represent the change in stock price from the previous day
stock_data['Change'] = stock_data['Close'].diff()

# Create a binary column to represent whether the stock price increased or decreased
stock_data['Direction'] = stock_data['Change'].apply(lambda x: 1 if x > 0 else 0)

# Define the lookback period
lookback = 30

# Scale the data using MinMaxScaler
scaler = MinMaxScaler()
scaled_data = scaler.fit_transform(stock_data[['Close', 'Volume']])

# Create the LSTM input sequences
X = []
y = []
for i in range(lookback, len(scaled_data)):
    X.append(scaled_data[i-lookback:i])
    y.append(stock_data.iloc[i]['Direction'])
X = np.array(X)
y = np.array(y)

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

# Define the LSTM model
model = Sequential()
model.add(LSTM(64, input_shape=(X_train.shape[1], X_train.shape[2])))
model.add(Dense(1, activation='sigmoid'))

# Compile the model
model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])

# Train the model on the training set
model.fit(X_train, y_train, epochs=10, validation_data=(X_test, y_test))

# Predict the next day's stock price direction
latest_data = stock_data.tail(lookback+1)
latest_data_scaled = scaler.transform(latest_data[['Close', 'Volume']])
X_latest = latest_data_scaled[:-1].reshape(1, lookback, 2)
y_latest_pred = model.predict(X_latest)
if y_latest_pred > 0.5:
    print('Next day\'s stock price for TCS is predicted to increase.')
else:
    print('Next day\'s stock price for TCS is predicted to decrease.')

# Load the last row from the training data
last_row = train_scaled[-1]

# Reshape the data to LSTM input shape
X_latest = last_row.reshape(1, lookback, len(selected_columns))

# Predict the next day's stock price
y_latest_pred = model.predict(X_latest)

# Inverse transform the prediction to original scale
y_latest_pred_inv = closing_price_scaler.inverse_transform(y_latest_pred.reshape(-1, 1))

# Print the predicted stock price if available
if not np.isnan(y_latest_pred_inv):
    print('Predicted stock price for the next day:', y_latest_pred_inv[0][0])
else:
    print('Unable to predict the stock price for the next day.')

# Import necessary libraries
import pandas as pd
from sklearn.preprocessing import MinMaxScaler
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense

# Load the stock data
stock_data = pd.read_csv('TCS.csv')

# Add a column to represent the change in stock price from the previous day
stock_data['Change'] = stock_data['Close'].diff()

# Create a binary column to represent whether the stock price increased or decreased
stock_data['Direction'] = stock_data['Change'].apply(lambda x: 1 if x > 0 else 0)

# Define the lookback period
lookback = 30

# Scale the data using MinMaxScaler
scaler = MinMaxScaler()
scaled_data = scaler.fit_transform(stock_data[['Close', 'Volume']])

# Create the LSTM input sequences
X = []
y = []
for i in range(lookback, len(scaled_data)):
    X.append(scaled_data[i-lookback:i])
    y.append(stock_data.iloc[i]['Direction'])
X = np.array(X)
y = np.array(y)

# Split the data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, shuffle=False)

# Define the LSTM model
model = Sequential()
model.add(LSTM(64, input_shape=(X_train.shape[1], X_train.shape[2])))
model.add(Dense(1, activation='sigmoid'))

# Compile the model
model.compile(loss='binary_crossentropy', optimizer='adam', metrics=['accuracy'])

# Train the model on the training set
model.fit(X_train, y_train, epochs=10, validation_data=(X_test, y_test))

# Predict the next day's stock price direction
latest_data = stock_data.tail(lookback+1)
latest_data_scaled = scaler.transform(latest_data[['Close', 'Volume']])
X_latest = latest_data_scaled[:-1].reshape(1, lookback, 2)
y_latest_pred = model.predict(X_latest)
if y_latest_pred > 0.5:
    print('Next day\'s stock price for TCS is predicted to increase.')
else:
    print('Next day\'s stock price for TCS is predicted to decrease.')